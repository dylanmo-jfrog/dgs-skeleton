name: "github-dgs-build"
on: 
  workflow_dispatch:
    inputs:
      env-number:
        required: true
        type: choice
        options:
        - '1'
        - '2'
        description: "Environment to use (1 EKS / 2 SaaS)"
      fail-scan:
        required: true
        type: boolean
        default: false
        description: "If true, will fail the build if watches violations are found"
      maven-repo:
        required: true
        type: string
        default: "default-maven-virtual"
        description: "Maven virtual repository"
      docker-repo:
        required: true
        type: string
        default: "default-docker-virtual"
        description: "Docker virtual repository"
      scan-watches:
        required: true
        type: string
        default: "webapp-watch"
        description: "The watches to use for the docker images scan(comma separated)"            
jobs:
  build:
    runs-on: ubuntu-latest
    # Here we install all the tools : docker buildx, QEMU, JDK 11, JFrog CLI
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'corretto'        
          cache: 'maven'
      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v2
        env:
          JF_ENV_1: ${{ secrets[format('JF_SECRET_ENV_{0}', github.event.inputs.env-number)] }}
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
        with:
          platforms: "linux/amd64,linux/arm64"
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        # We build & test the JAR file, scan it and if scan result ok, we publish it to our artifactory maven repository
      - name: Run Maven build
        env:
          MVN_VIRTUAL_REPO: ${{ github.event.inputs.maven-repo }}
          RT_DOCKER_REGISTRY: ${{ github.event.inputs.docker-repo }}
          JAR_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          SCAN_WATCHES: ${{ github.event.inputs.scan-watches }}
        run: |
          # Collect environment variables for the build
          jf rt bce ${{ env.JFROG_CLI_BUILD_NAME }}-jar ${{ env.JFROG_CLI_BUILD_NUMBER }} 
          jf mvnc --repo-resolve-releases=${{ env.MVN_VIRTUAL_REPO }} \
            --repo-deploy-releases=${{ env.MVN_VIRTUAL_REPO }} \
            --repo-resolve-snapshots=${{ env.MVN_VIRTUAL_REPO }} \
            --repo-deploy-snapshots=${{ env.MVN_VIRTUAL_REPO }}
          jf mvn --build-name=${{ env.JFROG_CLI_BUILD_NAME }}-jar --build-number=${{ env.JFROG_CLI_BUILD_NUMBER }} clean package
          # collect vcs info
          jf rt bag ${{ env.JFROG_CLI_BUILD_NAME }}-jar ${{ env.JFROG_CLI_BUILD_NUMBER }}
          jf scan --watches=${{ env.SCAN_WATCHES }} ./target/dgs-skeleton-${{ env.JAR_VERSION }}.jar --fail=false
          # if scan is ok publish the jar
          jf mvn --build-name=${{ env.JFROG_CLI_BUILD_NAME }}-jar --build-number=${{ env.JFROG_CLI_BUILD_NUMBER }} deploy
          # Publish build info
          jf rt bp ${{ env.JFROG_CLI_BUILD_NAME }}-jar ${{ env.JFROG_CLI_BUILD_NUMBER }}
      # Now multi arch docker build for our maven application
      # JFrog docker multi arch resources : 
      # https://jfrog.com/blog/the-more-the-merrier-multi-arch-docker-manifests-with-buildx-and-artifactory/
      # https://jfrog.com/knowledge-base/artifactory-how-to-use-jfrog-cli-to-add-build-info-to-images-built-with-docker-buildx/
      - name: Login to Artifactory Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets[format('JF_HOST_{0}', github.event.inputs.env-number)] }}
          username: ${{ secrets[format('JF_LOGIN_{0}', github.event.inputs.env-number)] }}
          password: ${{ secrets[format('JF_PWD_{0}', github.event.inputs.env-number)] }}
      - name: Build and push docker images
        env: 
          JAR_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          RT_REPO_PREFIX: ${{ secrets[format('JF_HOST_{0}', github.event.inputs.env-number)] }}/${{ github.event.inputs.docker-repo }}/
        uses: docker/build-push-action@v3
        id: docker_build
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          outputs: |
            type=image
          build-args: |
            JAR_FILE_NAME=dgs-skeleton-${{ env.JAR_VERSION }}.jar
            RT_REPO_PREFIX=${{ env.RT_REPO_PREFIX }}
          tags: ${{ secrets[format('JF_HOST_{0}', github.event.inputs.env-number)] }}/${{ github.event.inputs.docker-repo }}/multiarch/dgs-graphql:${{ env.JAR_VERSION }}
      - name: Scan & push Docker build info
        env:
          JAR_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          RT_DOCKER_HOST: ${{ secrets[format('JF_HOST_{0}', github.event.inputs.env-number)] }}
          RT_REPO_PREFIX: ${{ secrets[format('JF_HOST_{0}', github.event.inputs.env-number)] }}/${{ github.event.inputs.docker-repo }}/
        run: |
          echo ${{ secrets[format('JF_HOST_{0}', github.event.inputs.env-number)] }}/${{ github.event.inputs.docker-repo }}/multiarch/dgs-graphql:${{ env.JAR_VERSION }}@${{ steps.docker_build.outputs.ImageID }} > ./image-file-details.txt
          # Collect environment variables for the build
          jf rt bce ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }} 
          # collect vcs info
          jf rt bag ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }}
          # As the docker images have been built by buildx, we don't have them locally, 
          # so we link the build info to the already published image in previous step
          jf rt bdc ${{ github.event.inputs.docker-repo }} --image-file ./image-file-details.txt --build-name ${{ env.JFROG_CLI_BUILD_NAME }}-docker --build-number ${{ env.JFROG_CLI_BUILD_NUMBER }}
          #jf docker build --build-arg JAR_FILE_NAME=dgs-skeleton-$JAR_VERSION.jar --build-arg RT_REPO_PREFIX=${{ env.RT_REPO_PREFIX }} -t ${{ env.RT_REPO_PREFIX }}dgs-graphql:$JAR_VERSION .
          #jf docker push ${{ env.RT_REPO_PREFIX }}dgs-graphql:$JAR_VERSION
          # Publish build info
          jf rt bp ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }}

