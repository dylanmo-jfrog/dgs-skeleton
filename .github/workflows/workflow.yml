name: "github-dgs-build"
on: 
  schedule:
    - cron: "0 0 * * *"  
  workflow_dispatch:
    inputs:
      maven-repo:
        required: true
        type: string
        default: "dro-backend-maven-virtual"
        description: "Maven virtual repository"
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      DOCKER_REPO: 'dro-oci-dev-local'
      IMAGE_NAME: 'graphql-dgs-tcat'
    permissions:
      id-token: write
      contents: read
      actions: read 
      attestations: write    
      packages: write    
    # Here we install all the tools : docker buildx, QEMU, JDK 11, JFrog CLI
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'corretto'        
          cache: 'maven'
      - name: Setup JFrog CLI
        id: setup-cli
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: https://${{ vars.JF_HOST }}/
          JF_PROJECT: ${{ vars.JF_PROJECT_KEY }}
        with:
            oidc-provider-name: davidro-github-integration
            oidc-audience: davidro-github
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        # We build & test the WAR file, scan it and if scan result ok, we publish it to our artifactory maven repository
      - name: Run Maven build 
        env:
          MVN_VIRTUAL_REPO: ${{ github.event.inputs.maven-repo }}
          PKG_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          JF_PROJECT: ${{ vars.JF_PROJECT_KEY }}
        run: |
            # Collect environment variables for the build
            jf rt bce ${{ env.JFROG_CLI_BUILD_NAME }}-war ${{ env.JFROG_CLI_BUILD_NUMBER }} 
            jf mvnc --repo-resolve-releases=${{ env.MVN_VIRTUAL_REPO }} \
              --repo-deploy-releases=${{ env.MVN_VIRTUAL_REPO }} \
              --repo-resolve-snapshots=${{ env.MVN_VIRTUAL_REPO }} \
              --repo-deploy-snapshots=${{ env.MVN_VIRTUAL_REPO }}
            jf rt bag ${{ env.JFROG_CLI_BUILD_NAME }}-war ${{ env.JFROG_CLI_BUILD_NUMBER }} 
            jf mvn -f pom.xml -Drevision=1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0 -Dmaven.test.skip=true clean package
            jf mvn -f pom.xml -Drevision=1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0 -Dmaven.test.skip=true --build-name=${{ env.JFROG_CLI_BUILD_NAME }}-war --build-number=${{ env.JFROG_CLI_BUILD_NUMBER }} deploy
            # Publish build info
            jf rt bp ${{ env.JFROG_CLI_BUILD_NAME }}-war ${{ env.JFROG_CLI_BUILD_NUMBER }}
      - name: Authenticate Docker
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.JF_HOST }}
          username: ${{ steps.setup-cli.outputs.oidc-user }}
          password: ${{ steps.setup-cli.outputs.oidc-token }}      
      - name: Build and push docker tomcat + war based docker images
        env: 
          PKG_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          JF_PROJECT: ${{ vars.JF_PROJECT_KEY }}
        uses: docker/build-push-action@v6
        id: docker_build
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          provenance: true
          push: true
          build-args: |
            WAR_FILE_NAME=dgs-skeleton-webapp-${{ env.PKG_VERSION }}.war
          tags: ${{ vars.JF_HOST }}/${{ env.DOCKER_REPO }}/${{ env.IMAGE_NAME}}:${{ env.PKG_VERSION }}
      - name: Push Docker build info
        env:
          PKG_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          JF_PROJECT: ${{ vars.JF_PROJECT_KEY }}
        run: |
          echo ${{ vars.JF_HOST }}/${{ env.DOCKER_REPO }}/${{ env.IMAGE_NAME}}:${{ env.PKG_VERSION }}@${{ steps.docker_build.outputs.digest }} > ./image-metadata.json
          # Collect environment variables for the build
          jf rt bce ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }} 
          # collect vcs info
          jf rt bag ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }}
          # As the docker images have been built by buildx, we don't have them locally, 
          # so we link the build info to the already published images in previous steps
          jf rt bdc ${{ github.event.inputs.docker-repo }} --image-file ./image-metadata.json --build-name ${{ env.JFROG_CLI_BUILD_NAME }}-docker --build-number ${{ env.JFROG_CLI_BUILD_NUMBER }}
          # Publish build info
          jf rt bp ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }}
      - name: Scan Docker build info
        env:
          PKG_VERSION: 1.${{ env.JFROG_CLI_BUILD_NUMBER }}.0
          JF_PROJECT: ${{ vars.JF_PROJECT_KEY }}
          RT_REPO_PREFIX: ${{ vars.JF_HOST }}/${{ github.event.inputs.docker-repo }}/
        run: |
          # Xray build scan example
          jf bs --fail=false ${{ env.JFROG_CLI_BUILD_NAME }}-docker ${{ env.JFROG_CLI_BUILD_NUMBER }}
          # Tag release with extra properties
          jf rt sp "drobundle.status=ok;drobundle.version=1.${{ env.JFROG_CLI_BUILD_NUMBER }} --spec tagspecs.json --spec-vars="dockerRepo=${{ github.event.inputs.docker-repo }};imgPrefix=graphql-dgs-tcat;buildName=${{ env.JFROG_CLI_BUILD_NAME }}-docker;buildNumber=${{ env.JFROG_CLI_BUILD_NUMBER }}"

